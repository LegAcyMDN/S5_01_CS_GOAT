@page "/viewModel/{WearId:int}"
@using HomagGroup.Blazor3D.Enums
@using HomagGroup.Blazor3D.Events
@using HomagGroup.Blazor3D.Lights
@using HomagGroup.Blazor3D.Maths
@using HomagGroup.Blazor3D.Scenes
@using HomagGroup.Blazor3D.Settings
@using HomagGroup.Blazor3D.Viewers
@using S5_01_Blazor_CS_GOAT.Models
@using S5_01_Blazor_CS_GOAT.Service
@* @rendermode @(new InteractiveServerRenderMode(prerender: false)) *@
@implements IDisposable
@inject IThreeDModelService<ThreeDModel> ThreeDModelRepository
@inject CacheService CacheService
@inject IJSRuntime JS


<h3>3DView</h3>

<div class="row justify-content-center">
    <div class="col-6" style="height:500px;">
        <Viewer @ref="View3D1" Scene=scene />
    </div>

    <div>@msg</div>
</div>

@if (modelUrl != null)
{
    <h1>@modelUrl</h1>
}



<script src="js/cacheHelper.js"></script>

@code {
    [Parameter]
    public required int WearId { get; set; }


    private Viewer View3D1 = null!;
    private Scene scene = new Scene();
    private Guid loadedObjectGuid = Guid.NewGuid();
    private string msg = string.Empty;
    
    private string? modelUrl;
    private string? textureUrl;
    
    

    public void Dispose()
    {
        View3D1.ObjectLoaded -= OnObjectLoaded;
        View3D1.JsModuleLoaded -= OnJsModuleLoaded;
    }
    
    protected override Task OnInitializedAsync()
    {
        AddLights();
        return base.OnInitializedAsync();
    }
    
    private void AddLights(){
        scene.Add(new AmbientLight());
        scene.Add(new PointLight()
        {
            Intensity = 0.5f,
            Position = new Vector3(100, 200, 100)
        });
        scene.Add(new PointLight()
        {
            Intensity = 1f,
            Position = new Vector3(5, 5, 5)
        });
    }

    
    
    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // subscribe events only once
            View3D1.ObjectLoaded += OnObjectLoaded;
            View3D1.JsModuleLoaded += OnJsModuleLoaded;
        }

        return base.OnAfterRenderAsync(firstRender);
    }
    private record CacheResult(bool ok, string message);
    
private async Task OnJsModuleLoaded()
{
    ThreeDModel weapon3DModelObject = await ThreeDModelRepository.GetByIdAsync(WearId);
    string weaponName = weapon3DModelObject.ItemModel;
    string pathModelOrLegacy = weapon3DModelObject.UvType == 1 ? "models/legacy/" : "models/model/";
    
    // STEP 1: Cache BIN file first and get its blob URL
    await CacheService.CacheLocalFile("/" + pathModelOrLegacy + weaponName + ".bin", weaponName + ".bin");
    var binBlobUrl = await CacheService.GetCachedUrl(weaponName + ".bin");
    
    // STEP 2: Fetch and cache texture(s) from API
    await CacheService.FetchAndCacheImage(
#if DEBUG
        "https://localhost:7009/api/wear/get3dmodel/" + WearId,
#else
        "https://apicsgoat-h7bhhpd4e7bnc9bh.eastus-01.azurewebsites.net/api/" + WearId,
#endif
        "applied_texture.png" // This will be unused for multiple textures
    );
    
    
    // STEP 3: Handle single or multiple textures
    var textureUrls = new Dictionary<string, string>();
    
    if (weapon3DModelObject.Texture.Count == 1)
    {
        // Single texture case
        var textureBlobUrl = await CacheService.GetCachedUrl("applied_texture.png");
        textureUrls["applied_texture.png"] = textureBlobUrl;
    }
    else if (weapon3DModelObject.Texture.Count == 2)
    {
        // Multiple texture case - cache both textures separately
        await CacheTexture(weapon3DModelObject.Texture[0], "applied_texture_l.png");
        await CacheTexture(weapon3DModelObject.Texture[1], "applied_texture_r.png");
        
        var textureLBlobUrl = await CacheService.GetCachedUrl("applied_texture_l.png");
        var textureRBlobUrl = await CacheService.GetCachedUrl("applied_texture_r.png");
        
        textureUrls["applied_texture_l.png"] = textureLBlobUrl;
        textureUrls["applied_texture_r.png"] = textureRBlobUrl;
    }
    
    // STEP 4: Handle SSG08 special case - add static textures
    if (weaponName == "weapon_snip_ssg08" && weapon3DModelObject.UvType == 1)
    {
        // Cache the static lens texture
        await CacheService.CacheLocalFile("/models/ssg_lens.png", "ssg_lens.png");
        var lensUrl = await CacheService.GetCachedUrl("ssg_lens.png");
        textureUrls["ssg_lens.png"] = lensUrl;
        
        // Cache the static scope texture
        await CacheService.CacheLocalFile("/models/ssg_scope.png", "ssg_scope.png");
        var scopeUrl = await CacheService.GetCachedUrl("ssg_scope.png");
        textureUrls["ssg_scope.png"] = scopeUrl;
        
        Console.WriteLine($"SSG08 Lens URL: {lensUrl}");
        Console.WriteLine($"SSG08 Scope URL: {scopeUrl}");
    }
    
    // STEP 5: Cache GLTF with modified URIs pointing to blob URLs
    await CacheService.CacheGltfWithBlobUrls(
        "/" + pathModelOrLegacy + weaponName + ".gltf",
        weaponName + ".gltf",
        binBlobUrl,
        textureUrls
    );
    
    // STEP 6: Get the modified GLTF blob URL
    modelUrl = await CacheService.GetCachedUrl(weaponName + ".gltf");
    
    Console.WriteLine($"Model URL: {modelUrl}");
    Console.WriteLine($"Bin URL: {binBlobUrl}");
    foreach (var texture in textureUrls)
    {
        Console.WriteLine($"Texture {texture.Key}: {texture.Value}");
    }
    
    // STEP 7: Load the model
    var settings = new ImportSettings
    {
        Format = Import3DFormats.Gltf,
        FileURL = modelUrl,
    };
    loadedObjectGuid = await View3D1.Import3DModelAsync(settings);
    await View3D1.SetCameraPositionAsync(new Vector3(45, 30, 0), new Vector3(0, 0, 0));
}

// Helper method to cache individual texture bytes
private async Task CacheTexture(byte[] textureBytes, string cacheKey)
{
    await JS.InvokeAsync<bool>(
        "cacheHelper.putInCache",
        "model-cache",
        cacheKey,
        textureBytes
    );
}
    
    private Task OnObjectLoaded(Object3DArgs e)
    {
        // After object is loaded to component scene, you can locate it's C# clone in the scene.Children
        // At the moment, only  Object3D.Uuid and Object3D.Type properties are syncronized.
        foreach (var item in scene.Children)
        {
            if (item.Uuid == e.UUID)
            {
                this.msg = $"loaded object with id = {e.UUID} and type {item.Type}. Initial guid was {loadedObjectGuid}";
                StateHasChanged();
                break;
            }
        }
        return Task.CompletedTask;
    }

}